{"version":3,"sources":["augmentedReality/imageRecognition/tensorflow.ts","augmentedReality/solver/sudokuSolver.ts","augmentedReality/imageProcessing/getLargestConnectedComponent.ts","augmentedReality/imageProcessing/findHomographicTransform.ts","augmentedReality/imageProcessing/Image.ts","augmentedReality/imageProcessing/captureImage.ts","augmentedReality/imageProcessing/boxBlur.ts","augmentedReality/imageProcessing/adaptiveThreshold.ts","augmentedReality/imageProcessing/getCornerPoints.ts","augmentedReality/imageProcessing/applyHomographicTransform.ts","augmentedReality/imageProcessing/extractBoxes.ts","components/StatsPanel.tsx","App.tsx","augmentedReality/Processor.ts","serviceWorker.ts","index.tsx"],"names":["setWasmPath","process","MODEL_URL","CLASSES","_model","undefined","modelLoadingPromise","loadModel","a","Promise","resolve","reject","tf","getClasses","logits","array","logitsArray","classes","map","values","maxProb","maxIndex","forEach","value","index","fillInPrediction","boxes","model","images","box","img","fromPixels","numberImage","toImageData","resizeBilinear","toFloat","mean","std","variance","sqrt","sub","div","reshape","input","predict","batchSize","length","className","contents","then","console","log","error","Data","column","guess","left","right","up","down","this","node","Column","size","Guess","x","y","entry","isKnown","SudokuSolver","columnRoot","columnLookup","rowLookup","solution","col","insertRight","push","entryColIdx","entryColumn","entryConstraint","insertDown","rowColIdx","rowColumn","rowConstraint","colColIdx","colCol","columnConstraint","boxX","Math","floor","boxColumnIndex","boxColumn","boxConstraint","row","cover","smallestSize","smallestColumn","depth","Error","getSmallestColumn","search","uncover","pop","ConnectedRegion","points","topLeft","bottomRight","bounds","width","height","getConnectedComponent","image","bytes","minX","minY","maxX","maxY","frontier","seed","min","max","dy","dx","getLargestConnectedComponent","minAspectRatio","maxAspectRatio","minSize","maxSize","maxRegion","tmp","clone","region","aspectRatio","findHomographicTransform","corners","A","math","set","topRight","bottomLeft","B","A_t","lamda","get","b","c","d","e","f","g","h","transformPoint","point","tranform","sxPre1","sxPre2","syPre1","syPre2","Image","Uint8ClampedArray","x1","y1","x2","y2","imageData","ImageData","data","captureImage","video","canvas","document","createElement","videoWidth","videoHeight","context","getContext","drawImage","getImageData","readP","precomputed","w","boxBlur","src","boxw","boxh","result","Array","dst","tot","precompute","mul","adaptiveThreshold","threshold","blurSize","blurredBytes","getNearestPoint","closestPoint","minDistance","Number","MAX_SAFE_INTEGER","distance","abs","getCornerPoints","extractSquareFromRegion","source","withSize","sx","sy","extractBoxes","greyScale","thresholded","results","boxSize","searchSize","pointsCount","searchX1","searchX2","searchY2","searchY","searchX","component","foundWidth","foundHeight","subImage","StatsPanel","imageCaptureTime","thresholdTime","connectedComponentTime","getCornerPointsTime","extractImageTime","extractBoxesTime","ocrTime","solveTime","round","processor","isVideoRunning","isProcessing","gridLines","solvedPuzzle","captureTime","cornerPointTime","extractPuzzleTime","neuralNetTime","navigator","mediaDevices","getUserMedia","facingMode","audio","stream","canPlayListener","removeEventListener","emit","processFrame","addEventListener","srcObject","play","transform","l","p1","PROCESSING_SIZE","p2","digit","textPosition","digitRotation","atan2","digitHeight","position","solver","sol","getTextDetailsForBox","topLineLength","leftLineLength","rightLineLength","bottomLineLength","startTime","performance","now","largestConnectedComponent","potentialCorners","sanityCheckCorners","createGridLines","extractedImageGreyScale","extractedImageThresholded","setNumber","createSolvedPuzzle","setTimeout","EventEmitter","App","videoRef","useRef","previewCanvasRef","useState","setVideoWidth","setVideoHeight","setImageCaptureTime","setThresholdTime","setConnectedComponentTime","setGetCornerPOintsTime","setExtractImageTime","setExtractBoxesTime","setOcrTime","setSolveTime","useEffect","current","startVideo","alert","message","interval","window","setInterval","strokeStyle","fillStyle","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","fill","line","font","translate","rotate","PI","fillText","toString","setTransform","clearInterval","videoReadyListener","on","off","ref","playsInline","muted","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.1e446f3c.chunk.js","sourcesContent":["import * as tf from \"@tensorflow/tfjs\";\nimport { setWasmPath } from \"@tensorflow/tfjs-backend-wasm\";\nimport { PuzzleBox } from \"../imageProcessing/extractBoxes\";\n\nsetWasmPath(`${process.env.PUBLIC_URL}/sudoku/tfjs-backend-wasm.wasm`);\nconst MODEL_URL = `${process.env.PUBLIC_URL}/sudoku/tfjs_model/model.json`;\n\nconst CLASSES = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst IMAGE_SIZE = 20;\nlet _model: tf.LayersModel = undefined;\nlet modelLoadingPromise: Promise<tf.LayersModel> = undefined;\n\nasync function loadModel() {\n  if (_model) {\n    return _model;\n  }\n  if (modelLoadingPromise) {\n    return modelLoadingPromise;\n  }\n  modelLoadingPromise = new Promise(async (resolve, reject) => {\n    await tf.setBackend(\"wasm\");\n    _model = await tf.loadLayersModel(MODEL_URL);\n    resolve(_model);\n  });\n}\nloadModel().then(() => console.log(\"Model Loaded\", console.error));\n\n/**\n * Work out what the class should be from the results of the neural network prediction\n * @param logits\n */\nexport async function getClasses(logits: tf.Tensor<tf.Rank>) {\n  const logitsArray = (await logits.array()) as number[][];\n  const classes = logitsArray.map((values) => {\n    let maxProb = 0;\n    let maxIndex = 0;\n    values.forEach((value, index) => {\n      if (value > maxProb) {\n        maxProb = value;\n        maxIndex = index;\n      }\n    });\n    return CLASSES[maxIndex];\n  });\n  return classes;\n}\n\n/**\n * Apply our neural network to the extracted images\n * @param boxes A set of puzzle boxes containing images\n */\nexport default async function fillInPrediction(boxes: PuzzleBox[]) {\n  const model = await loadModel();\n  const logits = tf.tidy(() => {\n    // convert the images into tensors and process them in the same way we did during training\n    // if you change the code in the training then update the code here\n    const images = boxes.map((box) => {\n      const img = tf.browser\n        .fromPixels(box.numberImage.toImageData(), 1)\n        .resizeBilinear([IMAGE_SIZE, IMAGE_SIZE])\n        .toFloat();\n      const mean = img.mean();\n      const std = tf.moments(img).variance.sqrt();\n      const normalized = img.sub(mean).div(std);\n      const batched = normalized.reshape([1, IMAGE_SIZE, IMAGE_SIZE, 1]);\n      return batched;\n    });\n    // concatentate all the images for processing all at once\n    const input = tf.concat(images);\n    // Make the predictions\n    return model.predict(input, {\n      batchSize: boxes.length,\n    });\n  });\n  // Convert logits to probabilities and class names.\n  const classes = await getClasses(logits as tf.Tensor<tf.Rank>);\n  // fill in the boxes with the results\n  classes.forEach((className, index) => (boxes[index].contents = className));\n}\n","// cicular linked list element with links up, down, left and right\nclass Data {\n  left: Data;\n  right: Data;\n  up: Data;\n  down: Data;\n  column: Column | null;\n  guess: Guess | null;\n  constructor(column: Column = null, guess: Guess = null) {\n    this.column = column;\n    this.guess = guess;\n    // start of pointing at ourself\n    this.left = this;\n    this.right = this;\n    this.up = this;\n    this.down = this;\n  }\n  insertRight(node: Data) {\n    node.left = this;\n    node.right = this.right;\n    this.right.left = node;\n    this.right = node;\n  }\n  insertLeft(node: Data) {\n    node.right = this;\n    node.left = this.left;\n    this.left.right = node;\n    this.left = node;\n  }\n  insertUp(node: Data) {\n    node.down = this;\n    node.up = this.up;\n    this.up.down = node;\n    this.up = node;\n  }\n  insertDown(node: Data) {\n    node.up = this;\n    node.down = this.down;\n    this.down.up = node;\n    this.down = node;\n  }\n}\n\nclass Column extends Data {\n  size: number;\n  constructor() {\n    super();\n    this.size = 0;\n  }\n}\n\nclass Guess {\n  x: number;\n  y: number;\n  entry: number;\n  // flag to indicate if this was a known value - used when displaying the solution\n  isKnown: boolean = false;\n  constructor(x: number, y: number, entry: number) {\n    this.x = x;\n    this.y = y;\n    this.entry = entry;\n  }\n}\n\nexport default class SudokuSolver {\n  columnRoot: Column; // root column object\n  columnLookup: Column[] = [];\n  rowLookup: Data[] = [];\n  solution: Data[] = []; // the solution\n\n  // Setup the circular lists for the X algorithm to work on\n  public constructor() {\n    // construct the rows and columns\n    // https://en.wikipedia.org/wiki/Exact_cover#Sudoku and https://www.stolaf.edu//people/hansonr/sudoku/exactcovermatrix.htm\n    // https://www.kth.se/social/files/58861771f276547fe1dbf8d1/HLaestanderMHarrysson_dkand14.pdf\n\n    // create a doubly linked list of column headers\n    this.columnRoot = new Column();\n    for (let col = 0; col < 81 * 4; col++) {\n      const column = new Column();\n      this.columnRoot.insertRight(column);\n      // stash the column in a quick lookup\n      this.columnLookup.push(column);\n    }\n    // create a doubly linked list of rows and populate the columns for each row\n    for (let x = 0; x < 9; x++) {\n      for (let y = 0; y < 9; y++) {\n        for (let entry = 0; entry < 9; entry++) {\n          const guess = new Guess(x, y, entry + 1);\n          // create a node for the cell entry\n          const entryColIdx = y * 9 + x;\n          const entryColumn = this.columnLookup[entryColIdx];\n          const entryConstraint = new Data(entryColumn, guess);\n          this.rowLookup[(y * 9 + x) * 9 + entry] = entryConstraint;\n          // put the entry node in the corresponding column\n          entryColumn.insertDown(entryConstraint);\n          entryColumn.size++;\n\n          // create a node for the row constraint\n          const rowColIdx = 81 + y * 9 + entry;\n          const rowColumn = this.columnLookup[rowColIdx];\n          const rowConstraint = new Data(rowColumn, guess);\n          // and add it to the row\n          entryConstraint.insertRight(rowConstraint);\n          // and to the column for this constraint\n          rowColumn.insertDown(rowConstraint);\n          rowColumn.size++;\n\n          // create a node for the column constraint\n          const colColIdx = 81 * 2 + x * 9 + entry;\n          const colCol = this.columnLookup[colColIdx];\n          const columnConstraint = new Data(colCol, guess);\n          // and add it to the row\n          rowConstraint.insertRight(columnConstraint);\n          // and to the column for this constraint\n          colCol.insertDown(columnConstraint);\n          colCol.size++;\n\n          // create a node for the box constraint\n          const boxX = Math.floor(x / 3);\n          const boxY = Math.floor(y / 3);\n          const boxColumnIndex = 81 * 3 + (boxY * 3 + boxX) * 9 + entry;\n          const boxColumn = this.columnLookup[boxColumnIndex];\n          const boxConstraint = new Data(boxColumn, guess);\n          // add it the row\n          columnConstraint.insertRight(boxConstraint);\n          // add it to the column\n          boxColumn.insertDown(boxConstraint);\n          boxColumn.size++;\n        }\n      }\n    }\n  }\n\n  // set a number on the puzzle covering any of the constraints that it satisfies\n  setNumber(x: number, y: number, entry: number) {\n    // find the column\n    const row = this.rowLookup[(y * 9 + x) * 9 + entry];\n    row.guess.isKnown = true;\n    this.solution.push(row);\n    this.cover(row.column);\n    for (let right = row.right; right !== row; right = right.right) {\n      this.cover(right.column);\n    }\n  }\n\n  // get the column with the smallest number of rows - this should give us the quickest solution\n  getSmallestColumn() {\n    let smallestSize = (this.columnRoot.right as Column).size;\n    let smallestColumn = this.columnRoot.right as Column;\n    let col = this.columnRoot.right as Column;\n    while (col !== this.columnRoot) {\n      if (col.size < smallestSize) {\n        smallestSize = col.size;\n        smallestColumn = col;\n      }\n      col = col.right as Column;\n    }\n    return smallestColumn;\n  }\n\n  // search for a solution\n  search(depth: number = 0): boolean {\n    // give up if weve gone to deep - there probably isn't a solution\n    if (depth > 100) {\n      throw new Error(\"too deep - giving up\");\n    }\n    // we have no more columns - we have succeeded - send back the results\n    if (this.columnRoot.right === this.columnRoot) {\n      return true;\n    }\n    // pick the column with the fewest rows\n    let column = this.getSmallestColumn();\n    this.cover(column);\n    for (let row = column.down; row !== column; row = row.down) {\n      this.solution.push(row);\n      for (let right = row.right; right !== row; right = right.right) {\n        this.cover(right.column);\n      }\n      if (this.search(depth + 1)) {\n        return true;\n      }\n      // need to backtrack\n      for (let left = row.left; left !== row; left = left.left) {\n        this.uncover(left.column);\n      }\n      this.solution.pop();\n    }\n    // we've failed\n    this.uncover(column);\n    return false;\n  }\n\n  // cover a column - basically unlink the column from the list and unlink any rows from other columns\n  cover(column: Column) {\n    column.right.left = column.left;\n    column.left.right = column.right;\n    for (let row = column.down; row !== column; row = row.down) {\n      for (let right = row.right; right !== row; right = right.right) {\n        right.down.up = right.up;\n        right.up.down = right.down;\n        right.column.size--;\n      }\n    }\n  }\n\n  // uncover a column - put the rows back along with the column\n  uncover(column: Column) {\n    for (let row = column.up; row !== column; row = row.up) {\n      for (let left = row.left; left !== row; left = left.left) {\n        left.down.up = left;\n        left.up.down = left;\n        left.column.size++;\n      }\n    }\n    column.right.left = column;\n    column.left.right = column;\n  }\n}\n","import Image from \"./Image\";\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport class ConnectedRegion {\n  public points: Point[];\n  public bounds: { topLeft: Point; bottomRight: Point };\n  constructor(points: Point[], topLeft: Point, bottomRight: Point) {\n    this.points = points;\n    this.bounds = { topLeft, bottomRight };\n  }\n  get width() {\n    return this.bounds.bottomRight.x - this.bounds.topLeft.x;\n  }\n  get height() {\n    return this.bounds.bottomRight.y - this.bounds.topLeft.y;\n  }\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n\nexport function getConnectedComponent(\n  image: Image,\n  x: number,\n  y: number\n): ConnectedRegion {\n  const { width, height, bytes } = image;\n  let minX = x;\n  let minY = y;\n  let maxX = x;\n  let maxY = y;\n  const points: Point[] = [];\n  const frontier: Point[] = [];\n  points.push({ x, y });\n  frontier.push({ x, y });\n  bytes[y * width + x] = 0;\n  while (frontier.length > 0) {\n    const seed = frontier.pop()!;\n    minX = Math.min(seed.x, minX);\n    maxX = Math.max(seed.x, maxX);\n    minY = Math.min(seed.y, minY);\n    maxY = Math.max(seed.y, maxY);\n    for (\n      let dy = Math.max(0, seed.y - 1);\n      dy < height && dy <= seed.y + 1;\n      dy++\n    ) {\n      for (\n        let dx = Math.max(0, seed.x - 1);\n        dx < width && dx <= seed.x + 1;\n        dx++\n      ) {\n        if (bytes[dy * width + dx] === 255) {\n          points.push({ x: dx, y: dy });\n          frontier.push({ x: dx, y: dy });\n          bytes[dy * width + dx] = 0;\n        }\n      }\n    }\n  }\n  return new ConnectedRegion(\n    points,\n    { x: minX, y: minY },\n    { x: maxX, y: maxY }\n  );\n}\n\ntype ConnectedComponentOptions = {\n  minAspectRatio: number;\n  maxAspectRatio: number;\n  minSize: number;\n  maxSize: number;\n};\n\n/**\n *\n * @param image Input image\n * @param options: Filtering options\n */\nexport default function getLargestConnectedComponent(\n  image: Image,\n  {\n    minAspectRatio,\n    maxAspectRatio,\n    minSize,\n    maxSize,\n  }: ConnectedComponentOptions\n): ConnectedRegion | null {\n  let maxRegion: ConnectedRegion | null = null;\n  // clone the input image as this is a destructive operation\n  const tmp = image.clone();\n  const { width, height, bytes } = tmp;\n  for (let y = 0; y < height; y++) {\n    const row = y * width;\n    for (let x = 0; x < width; x++) {\n      if (bytes[row + x] === 255) {\n        const region = getConnectedComponent(tmp, x, y);\n        const width = region.bounds.bottomRight.x - region.bounds.topLeft.x;\n        const height = region.bounds.bottomRight.y - region.bounds.topLeft.y;\n        if (\n          region.aspectRatio >= minAspectRatio &&\n          region.aspectRatio <= maxAspectRatio &&\n          height >= minSize &&\n          width >= minSize &&\n          height <= maxSize &&\n          width <= maxSize\n        ) {\n          if (!maxRegion || region.points.length > maxRegion.points.length) {\n            maxRegion = region;\n          }\n        }\n      }\n    }\n  }\n  return maxRegion;\n}\n","import { Point } from \"./getLargestConnectedComponent\";\nimport * as math from \"mathjs\";\n\nexport interface Transform {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n  g: number;\n  h: number;\n}\n// see here for details http://alumni.media.mit.edu/~cwren/interpolator/\n// now available here https://web.archive.org/web/20071214081425/http://alumni.media.mit.edu/~cwren/interpolator/\nexport default function findHomographicTransform(\n  size: number,\n  corners: {\n    topLeft: Point;\n    topRight: Point;\n    bottomLeft: Point;\n    bottomRight: Point;\n  }\n): Transform {\n  const A = math.zeros(8, 8) as math.Matrix;\n\n  A.set([0, 2], 1);\n  A.set([1, 5], 1);\n  A.set([2, 0], size);\n  A.set([2, 2], 1);\n  A.set([2, 6], -size * corners.topRight.x);\n  A.set([3, 3], size);\n  A.set([3, 5], 1);\n  A.set([3, 6], -size * corners.topRight.y);\n  A.set([4, 1], size);\n  A.set([4, 2], 1);\n  A.set([4, 7], -size * corners.bottomLeft.x);\n  A.set([5, 4], size);\n  A.set([5, 5], 1);\n  A.set([5, 7], -size * corners.bottomLeft.y);\n  A.set([6, 0], size);\n  A.set([6, 1], size);\n  A.set([6, 2], 1);\n  A.set([6, 6], -size * corners.bottomRight.x);\n  A.set([6, 7], -size * corners.bottomRight.x);\n  A.set([7, 3], size);\n  A.set([7, 4], size);\n  A.set([7, 5], 1);\n  A.set([7, 6], -size * corners.bottomRight.y);\n  A.set([7, 7], -size * corners.bottomRight.y);\n\n  const B = math.matrix([\n    corners.topLeft.x,\n    corners.topLeft.y,\n    corners.topRight.x,\n    corners.topRight.y,\n    corners.bottomLeft.x,\n    corners.bottomLeft.y,\n    corners.bottomRight.x,\n    corners.bottomRight.y,\n  ]);\n\n  const A_t = math.transpose(A);\n  const lamda = math.multiply(\n    math.multiply(math.inv(math.multiply(A_t, A)), A_t),\n    B\n  );\n\n  const a = lamda.get([0]);\n  const b = lamda.get([1]);\n  const c = lamda.get([2]);\n  const d = lamda.get([3]);\n  const e = lamda.get([4]);\n  const f = lamda.get([5]);\n  const g = lamda.get([6]);\n  const h = lamda.get([7]);\n  return { a, b, c, d, e, f, g, h };\n}\n\nexport function transformPoint(point: Point, tranform: Transform) {\n  const { a, b, c, d, e, f, g, h } = tranform;\n  const { x, y } = point;\n\n  const sxPre1 = b * y + c;\n  const sxPre2 = h * y + 1;\n  const syPre1 = e * y + f;\n  const syPre2 = h * y + 1;\n\n  const sx = Math.floor((a * x + sxPre1) / (g * x + sxPre2));\n  const sy = Math.floor((d * x + syPre1) / (g * x + syPre2));\n  return { x: sx, y: sy };\n}\n","export default class Image {\n  public bytes: Uint8ClampedArray;\n  public width: number;\n  public height: number;\n  constructor(bytes: Uint8ClampedArray, width: number, height: number) {\n    this.bytes = bytes;\n    this.width = width;\n    this.height = height;\n  }\n  static withSize(width: number, height: number) {\n    const bytes = new Uint8ClampedArray(width * height);\n    return new Image(bytes, width, height);\n  }\n  public clone(): Image {\n    return new Image(\n      new Uint8ClampedArray(this.bytes),\n      this.width,\n      this.height\n    );\n  }\n  public subImage(x1: number, y1: number, x2: number, y2: number): Image {\n    const width = x2 - x1;\n    const height = y2 - y1;\n    const bytes = new Uint8ClampedArray(width * height);\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        bytes[y * width + x] = this.bytes[(y + y1) * this.width + x + x1];\n      }\n    }\n    return new Image(bytes, width, height);\n  }\n  public toImageData(): ImageData {\n    const imageData = new ImageData(this.width, this.height);\n    for (let y = 0; y < this.height; y++) {\n      const row = y * this.width;\n      for (let x = 0; x < this.width; x++) {\n        const value = this.bytes[row + x];\n        imageData.data[(row + x) * 4] = value;\n        imageData.data[(row + x) * 4 + 1] = value;\n        imageData.data[(row + x) * 4 + 2] = value;\n        imageData.data[(row + x) * 4 + 3] = 255;\n      }\n    }\n    return imageData;\n  }\n}\n","import Image from \"./Image\";\n\nexport default function captureImage(video: HTMLVideoElement) {\n  const canvas = document.createElement(\"canvas\");\n  const width = video.videoWidth;\n  const height = video.videoHeight;\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext(\"2d\");\n  // draw the video to the canvas\n  context!.drawImage(video, 0, 0, width, height);\n  // get the raw image bytes\n  const imageData = context!.getImageData(0, 0, width, height);\n  // convert to greyscale\n  const bytes = new Uint8ClampedArray(width * height);\n  for (let y = 0; y < height; y++) {\n    const row = y * width;\n    for (let x = 0; x < width; x++) {\n      //const r = imageData.data[(y * width + x) * 4];\n      const g = imageData.data[(row + x) * 4 + 1];\n      // const b = imageData.data[(y * width + x) * 4 + 2];\n      // https://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n      // const grey = 0.299 * r + 0.587 * g + 0.114 * b;\n      bytes[row + x] = g;\n    }\n  }\n  return new Image(bytes, width, height);\n}\n","import Image from \"./Image\";\n\n// Fast box blur algorithm\n// see - https://www.gamasutra.com/view/feature/3102/four_tricks_for_fast_blurring_in_.php?print=1\n\nfunction precompute(\n  bytes: Uint8ClampedArray,\n  width: number,\n  height: number\n): number[] {\n  const result: number[] = new Array(bytes.length);\n  let dst = 0;\n  let src = 0;\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let tot = bytes[src];\n      if (x > 0) tot += result[dst - 1];\n      if (y > 0) tot += result[dst - width];\n      if (x > 0 && y > 0) tot -= result[dst - width - 1];\n      result[dst] = tot;\n      dst++;\n      src++;\n    }\n  }\n  return result;\n}\n\n// this is a utility function used by DoBoxBlur below\nfunction readP(\n  precomputed: number[],\n  w: number,\n  h: number,\n  x: number,\n  y: number\n): number {\n  if (x < 0) x = 0;\n  else if (x >= w) x = w - 1;\n  if (y < 0) y = 0;\n  else if (y >= h) y = h - 1;\n  return precomputed[x + y * w];\n}\n\nexport default function boxBlur(src: Image, boxw: number, boxh: number): Image {\n  const { width, height, bytes } = src;\n  const precomputed = precompute(bytes, width, height);\n  const result = new Uint8ClampedArray(width * height);\n  let dst = 0;\n  const mul = 1.0 / ((boxw * 2 + 1) * (boxh * 2 + 1));\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const tot =\n        readP(precomputed, width, height, x + boxw, y + boxh) +\n        readP(precomputed, width, height, x - boxw, y - boxh) -\n        readP(precomputed, width, height, x - boxw, y + boxh) -\n        readP(precomputed, width, height, x + boxw, y - boxh);\n      result[dst] = tot * mul;\n      dst++;\n    }\n  }\n  return new Image(result, width, height);\n}\n","import Image from \"./Image\";\n// import gaussianBlur from \"./gaussianBlur\";\nimport boxBlur from \"./boxBlur\";\n\n/**\n * Applies adaptive thresholding to an image. Uses a fast box blur for speed.\n * @param image Image to threshold\n * @param threshold Threshold value - higher removes noise, lower more noise\n */\nexport default function adaptiveThreshold(\n  image: Image,\n  threshold: number,\n  blurSize: number\n): Image {\n  const { width, height, bytes } = image;\n  const blurred = boxBlur(image, blurSize, blurSize);\n  const blurredBytes = blurred.bytes;\n  for (let y = 0; y < height; y++) {\n    const row = y * width;\n    for (let x = 0; x < width; x++) {\n      bytes[row + width + x] =\n        blurredBytes[row + x] - bytes[row + width + x] > threshold ? 255 : 0;\n    }\n  }\n  return image;\n}\n","import { Point, ConnectedRegion } from \"./getLargestConnectedComponent\";\n\n/**\n * Finds the nearest point to another point using manhattan distance\n * @param points Array of points\n * @param x x coordinate of point\n * @param y y coordinate of point\n */\nfunction getNearestPoint(points: Point[], x: number, y: number) {\n  let closestPoint = points[0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n  points.forEach((point) => {\n    const dx = Math.abs(point.x - x);\n    const dy = Math.abs(point.y - y);\n    const distance = dx + dy;\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestPoint = point;\n    }\n  });\n  return closestPoint;\n}\n\nexport type CornerPoints = {\n  topLeft: Point;\n  topRight: Point;\n  bottomLeft: Point;\n  bottomRight: Point;\n};\n\n/**\n * Locate the corner points of a connected region\n * @param region A connected region\n */\nexport default function getCornerPoints(region: ConnectedRegion): CornerPoints {\n  // get the extents\n  const { x: minX, y: minY } = region.bounds.topLeft;\n  const { x: maxX, y: maxY } = region.bounds.bottomRight;\n  const { points } = region;\n  // find the points closest to the topleft, topright, bottomleft, and bottomright\n  return {\n    topLeft: getNearestPoint(points, minX, minY),\n    topRight: getNearestPoint(points, maxX, minY),\n    bottomLeft: getNearestPoint(points, minX, maxY),\n    bottomRight: getNearestPoint(points, maxX, maxY),\n  };\n}\n","import Image from \"./Image\";\nimport { Transform } from \"./findHomographicTransform\";\n\n/**\n * Extracts a square region from the source image using the transform\n * @param source Source image\n * @param size The size of the square area we want to extract\n * @param tranform The homography to apply to map to the source image\n */\nexport default function extractSquareFromRegion(\n  source: Image,\n  size: number,\n  tranform: Transform\n) {\n  const { a, b, c, d, e, f, g, h } = tranform;\n\n  const result = Image.withSize(size, size);\n  for (let y = 0; y < size; y++) {\n    const sxPre1 = b * y + c;\n    const sxPre2 = h * y + 1;\n    const syPre1 = e * y + f;\n    const syPre2 = h * y + 1;\n\n    for (let x = 0; x < size; x++) {\n      const sx = Math.floor((a * x + sxPre1) / (g * x + sxPre2));\n      const sy = Math.floor((d * x + syPre1) / (g * x + syPre2));\n      // TODO - should we interpolate this value?\n      result.bytes[y * size + x] = source.bytes[sy * source.width + sx];\n    }\n  }\n  return result;\n}\n","import Image from \"./Image\";\nimport { getConnectedComponent } from \"./getLargestConnectedComponent\";\n\nexport interface PuzzleBox {\n  x: number;\n  y: number;\n  minX: number;\n  maxX: number;\n  minY: number;\n  maxY: number;\n  numberImage: Image;\n  // filled in later by the OCR code\n  contents: number;\n}\n\n/**\n * Looks through each box in the puzzle image to see if there is a potential digit in it. If there is an image is extracted that should contain the digit.\n * @param greyScale The greyscale image of the puzzle\n * @param thresholded A thresholded version of the greyscale image\n */\nexport default function extractBoxes(greyScale: Image, thresholded: Image) {\n  const results: PuzzleBox[] = [];\n  const size = greyScale.width;\n  const boxSize = size / 9;\n  const searchSize = boxSize / 5;\n  // go through each box and see if it contains anything, if it does get the bounds of the contents and copy it from the greyScale image\n  for (let y = 0; y < 9; y++) {\n    for (let x = 0; x < 9; x++) {\n      let minX = Number.MAX_SAFE_INTEGER;\n      let minY = Number.MAX_SAFE_INTEGER;\n      let maxX = 0;\n      let maxY = 0;\n      let pointsCount = 0;\n      const searchX1 = x * boxSize + searchSize;\n      const searchY1 = y * boxSize + searchSize;\n      const searchX2 = x * boxSize + boxSize - searchSize;\n      const searchY2 = y * boxSize + boxSize - searchSize;\n      for (let searchY = searchY1; searchY < searchY2; searchY++) {\n        for (let searchX = searchX1; searchX < searchX2; searchX++) {\n          if (thresholded.bytes[searchY * size + searchX] === 255) {\n            const component = getConnectedComponent(\n              thresholded,\n              searchX,\n              searchY\n            );\n            const foundWidth =\n              component.bounds.bottomRight.x - component.bounds.topLeft.x;\n            const foundHeight =\n              component.bounds.bottomRight.y - component.bounds.topLeft.y;\n            if (\n              component.points.length > 10 &&\n              foundWidth < boxSize &&\n              foundHeight < boxSize\n            ) {\n              minX = Math.min(minX, component.bounds.topLeft.x);\n              minY = Math.min(minY, component.bounds.topLeft.y);\n              maxX = Math.max(maxX, component.bounds.bottomRight.x);\n              maxY = Math.max(maxY, component.bounds.bottomRight.y);\n              pointsCount += component.points.length;\n            }\n          }\n        }\n      }\n      // sanity check to make sure we actually found something and we didn't get something weird\n      const foundWidth = maxX - minX;\n      const foundHeight = maxY - minY;\n      if (\n        pointsCount > 10 &&\n        foundWidth < boxSize &&\n        foundHeight < boxSize &&\n        foundWidth > boxSize / 10 &&\n        foundHeight > boxSize / 3\n      ) {\n        const numberImage = greyScale.subImage(\n          Math.max(0, minX - 2),\n          Math.max(0, minY - 2),\n          Math.min(size - 1, maxX + 2),\n          Math.min(size - 1, maxY + 2)\n        );\n        results.push({\n          x,\n          y,\n          minX,\n          maxX,\n          minY,\n          maxY,\n          numberImage,\n          contents: 0,\n        });\n      }\n    }\n  }\n  return results;\n}\n","import React from \"react\";\n\nexport default function StatsPanel({\n  imageCaptureTime,\n  thresholdTime,\n  connectedComponentTime,\n  getCornerPointsTime,\n  extractImageTime,\n  extractBoxesTime,\n  ocrTime,\n  solveTime,\n}: {\n  imageCaptureTime: number;\n  thresholdTime: number;\n  connectedComponentTime: number;\n  getCornerPointsTime: number;\n  extractImageTime: number;\n  extractBoxesTime: number;\n  ocrTime: number;\n  solveTime: number;\n}) {\n  return (\n    <div className=\"stats-panel\">\n      <div>\n        <b>imageCaptureTime:</b> {Math.round(imageCaptureTime)}\n      </div>\n      <div>\n        <b>thresholdTime:</b> {Math.round(thresholdTime)}\n      </div>\n      <div>\n        <b>connectedComponentTime:</b> {Math.round(connectedComponentTime)}\n      </div>\n      <div>\n        <b>getCornerPointsTime:</b> {Math.round(getCornerPointsTime)}\n      </div>\n      <div>\n        <b>extractImageTime:</b> {Math.round(extractImageTime)}\n      </div>\n      <div>\n        <b>extractBoxesTime:</b> {Math.round(extractBoxesTime)}\n      </div>\n      <div>\n        <b>ocrTime:</b> {Math.round(ocrTime)}\n      </div>\n      <div>\n        <b>solveTime:</b> {Math.round(solveTime)}\n      </div>\n    </div>\n  );\n}\n","import React, { useRef, useState, useEffect } from \"react\";\nimport \"./App.css\";\nimport Processor, { VideoReadyPayload } from \"./augmentedReality/Processor\";\nimport StatsPanel from \"./components/StatsPanel\";\n\n// start processing video\nconst processor = new Processor();\n\nfunction App() {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const previewCanvasRef = useRef<HTMLCanvasElement>(null);\n\n  const [videoWidth, setVideoWidth] = useState(100);\n  const [videoHeight, setVideoHeight] = useState(100);\n\n  const [imageCaptureTime, setImageCaptureTime] = useState(0);\n  const [thresholdTime, setThresholdTime] = useState(0);\n  const [connectedComponentTime, setConnectedComponentTime] = useState(0);\n  const [getCornerPointsTime, setGetCornerPOintsTime] = useState(0);\n  const [extractImageTime, setExtractImageTime] = useState(0);\n  const [extractBoxesTime, setExtractBoxesTime] = useState(0);\n  const [ocrTime, setOcrTime] = useState(0);\n  const [solveTime, setSolveTime] = useState(0);\n\n  // start the video playing\n  useEffect(() => {\n    const video = videoRef.current;\n    if (video) {\n      processor.startVideo(video).then(\n        () => console.log(\"Video started\"),\n        (error) => alert(error.message)\n      );\n    }\n  }, [videoRef]);\n\n  // render the overlay\n  useEffect(() => {\n    const interval = window.setInterval(() => {\n      const canvas = previewCanvasRef.current;\n      if (canvas && processor.isVideoRunning) {\n        // update the peformance stats\n        setImageCaptureTime(processor.captureTime);\n        setThresholdTime(processor.thresholdTime);\n        setConnectedComponentTime(processor.connectedComponentTime);\n        setGetCornerPOintsTime(processor.cornerPointTime);\n        setExtractImageTime(processor.extractPuzzleTime);\n        setExtractBoxesTime(processor.extractBoxesTime);\n        setOcrTime(processor.neuralNetTime);\n        setSolveTime(processor.solveTime);\n        // display the output from the processor\n        const context = canvas.getContext(\"2d\");\n        if (context) {\n          context.drawImage(processor.video, 0, 0);\n          if (processor.corners) {\n            const {\n              topLeft,\n              topRight,\n              bottomLeft,\n              bottomRight,\n            } = processor.corners;\n            context.strokeStyle = \"rgba(0,200,0,0.5)\";\n            context.fillStyle = \"rgba(0,0,0,0.3)\";\n            context.lineWidth = 3;\n            context.beginPath();\n            context.moveTo(topLeft.x, topLeft.y);\n            context.lineTo(topRight.x, topRight.y);\n            context.lineTo(bottomRight.x, bottomRight.y);\n            context.lineTo(bottomLeft.x, bottomLeft.y);\n            context.closePath();\n            context.stroke();\n            context.fill();\n          }\n          if (processor.gridLines) {\n            context.strokeStyle = \"rgba(0,200,0,0.5)\";\n            context.lineWidth = 2;\n            processor.gridLines.forEach((line) => {\n              context.moveTo(line.p1.x, line.p1.y);\n              context.lineTo(line.p2.x, line.p2.y);\n            });\n            context.stroke();\n          }\n          if (processor.solvedPuzzle) {\n            context.fillStyle = \"rgba(0,200,0,1)\";\n            for (let y = 0; y < 9; y++) {\n              for (let x = 0; x < 9; x++) {\n                if (processor.solvedPuzzle[y][x]) {\n                  const {\n                    digit,\n                    digitHeight,\n                    digitRotation,\n                    position,\n                    isKnown,\n                  } = processor.solvedPuzzle[y][x];\n                  if (!isKnown) {\n                    context.font = `bold ${digitHeight}px sans-serif`;\n                    context.translate(position.x, position.y);\n                    context.rotate(Math.PI - digitRotation);\n                    context.fillText(\n                      digit.toString(),\n                      -digitHeight / 4,\n                      digitHeight / 3\n                    );\n                    context.setTransform();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }, 100);\n    return () => {\n      window.clearInterval(interval);\n    };\n  }, [previewCanvasRef]);\n\n  // update the video scale as needed\n  useEffect(() => {\n    function videoReadyListener({ width, height }: VideoReadyPayload) {\n      setVideoWidth(width);\n      setVideoHeight(height);\n    }\n    processor.on(\"videoReady\", videoReadyListener);\n    return () => {\n      processor.off(\"videoReady\", videoReadyListener);\n    };\n  });\n\n  return (\n    <div className=\"App\">\n      {/* need to have a visible video for mobile safari to work */}\n      <video\n        ref={videoRef}\n        className=\"video-preview\"\n        width={10}\n        height={10}\n        playsInline\n        muted\n      />\n      <canvas\n        ref={previewCanvasRef}\n        className=\"preview-canvas\"\n        width={videoWidth}\n        height={videoHeight}\n      />\n      <StatsPanel\n        imageCaptureTime={imageCaptureTime}\n        thresholdTime={thresholdTime}\n        connectedComponentTime={connectedComponentTime}\n        getCornerPointsTime={getCornerPointsTime}\n        extractImageTime={extractImageTime}\n        extractBoxesTime={extractBoxesTime}\n        ocrTime={ocrTime}\n        solveTime={solveTime}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import StrictEventEmitter from \"strict-event-emitter-types\";\nimport { EventEmitter } from \"events\";\nimport fillInPrediction from \"./imageRecognition/tensorflow\";\nimport SudokuSolver from \"./solver/sudokuSolver\";\nimport getLargestConnectedComponent, {\n  Point,\n} from \"./imageProcessing/getLargestConnectedComponent\";\nimport findHomographicTransform, {\n  Transform,\n  transformPoint,\n} from \"./imageProcessing/findHomographicTransform\";\nimport captureImage from \"./imageProcessing/captureImage\";\nimport adaptiveThreshold from \"./imageProcessing/adaptiveThreshold\";\nimport getCornerPoints from \"./imageProcessing/getCornerPoints\";\nimport extractSquareFromRegion from \"./imageProcessing/applyHomographicTransform\";\nimport extractBoxes from \"./imageProcessing/extractBoxes\";\n\n// minimum number of boxes we want before trying to solve the puzzle\nconst MIN_BOXES = 15;\n// size of image to use for processing\nconst PROCESSING_SIZE = 900;\n\nexport type VideoReadyPayload = { width: number; height: number };\n\ninterface ProcessorEvents {\n  videoReady: VideoReadyPayload;\n}\n\ntype ProcessorEventEmitter = StrictEventEmitter<EventEmitter, ProcessorEvents>;\n\ntype SolvedBox = {\n  // was this a known digit?\n  isKnown: boolean;\n  // the digit for this box\n  digit: number;\n  // a guess at how tall it should be drawn\n  digitHeight: number;\n  // a guess at the rotation to draw it at\n  digitRotation: number;\n  // where to draw it\n  position: Point;\n};\n\nexport default class Processor extends (EventEmitter as {\n  new (): ProcessorEventEmitter;\n}) {\n  // the source for our video\n  video: HTMLVideoElement;\n  // is the video actually running?\n  isVideoRunning: boolean = false;\n  // are we in the middle of processing a frame?\n  isProcessing: boolean = false;\n  // the detected corners of the puzzle in video space\n  corners: {\n    topLeft: Point;\n    topRight: Point;\n    bottomLeft: Point;\n    bottomRight: Point;\n  };\n  // the calculated grid lines in the video space\n  gridLines: { p1: Point; p2: Point }[];\n  // completely solved puzzle\n  solvedPuzzle: SolvedBox[][];\n  // performance stats\n  captureTime: number = 0;\n  thresholdTime: number = 0;\n  connectedComponentTime: number = 0;\n  cornerPointTime: number = 0;\n  extractPuzzleTime: number = 0;\n  extractBoxesTime: number = 0;\n  neuralNetTime: number = 0;\n  solveTime: number = 0;\n\n  /**\n   * Start streaming video from the back camera of a phone (or webcam on a computer)\n   * @param video A video element - needs to be on the page for iOS to work\n   */\n  async startVideo(video: HTMLVideoElement) {\n    this.video = video;\n    // start up the video feed\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: { facingMode: \"environment\", width: 640 },\n      audio: false,\n    });\n    // grab the video dimensions once it has started up\n    const canPlayListener = () => {\n      this.video.removeEventListener(\"canplay\", canPlayListener);\n      this.emit(\"videoReady\", {\n        width: this.video.videoWidth,\n        height: this.video.videoHeight,\n      });\n      this.isVideoRunning = true;\n      // start processing\n      this.processFrame();\n    };\n    this.video.addEventListener(\"canplay\", canPlayListener);\n    this.video.srcObject = stream;\n    this.video.play();\n  }\n\n  /**\n   * Creates a set of grid lines mapped onto video space\n   * @param transform The homographic transform to video space\n   */\n  createGridLines(transform: Transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const gridLines = [];\n    for (let l = 1; l < 9; l++) {\n      // horizonal line\n      gridLines.push({\n        p1: transformPoint({ x: 0, y: l * boxSize }, transform),\n        p2: transformPoint({ x: PROCESSING_SIZE, y: l * boxSize }, transform),\n      });\n      // vertical line\n      gridLines.push({\n        p1: transformPoint({ y: 0, x: l * boxSize }, transform),\n        p2: transformPoint({ y: PROCESSING_SIZE, x: l * boxSize }, transform),\n      });\n    }\n    return gridLines;\n  }\n\n  /**\n   * Create a set of cells with coordinates in video space for drawing digits\n   * @param x Cell X\n   * @param y Cell Y\n   * @param digit The digit\n   * @param isKnown Is it a known digit?\n   * @param transform The homographic transform to video space\n   */\n  getTextDetailsForBox(\n    x: number,\n    y: number,\n    digit: number,\n    isKnown: boolean,\n    transform: Transform\n  ): SolvedBox {\n    const boxSize = PROCESSING_SIZE / 9;\n    // work out the line that runs vertically through the box in the original image space\n    const p1 = transformPoint(\n      { x: (x + 0.5) * boxSize, y: y * boxSize },\n      transform\n    );\n    const p2 = transformPoint(\n      { x: (x + 0.5) * boxSize, y: (y + 1) * boxSize },\n      transform\n    );\n    // the center of the box\n    const textPosition = transformPoint(\n      { x: (x + 0.5) * boxSize, y: (y + 0.5) * boxSize },\n      transform\n    );\n    // approximate angle of the text in the box\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    const digitRotation = Math.atan2(dx, dy);\n\n    // appriximate height of the text in the box\n    const digitHeight = 0.8 * Math.sqrt(dx * dx + dy * dy);\n\n    return {\n      digit,\n      digitHeight,\n      digitRotation,\n      isKnown: isKnown,\n      position: textPosition,\n    };\n  }\n\n  /**\n   * Map from the found solution to something that can be displayed in video space\n   * @param solver The solver with the solution\n   * @param transform The transform to video space\n   */\n  createSolvedPuzzle(solver: SudokuSolver, transform: Transform) {\n    const results: SolvedBox[][] = new Array(9);\n    for (let y = 0; y < 9; y++) {\n      results[y] = new Array(9);\n    }\n    solver.solution.forEach((sol) => {\n      const { x, y, entry, isKnown } = sol.guess;\n      results[y][x] = this.getTextDetailsForBox(\n        x,\n        y,\n        entry,\n        isKnown,\n        transform\n      );\n    });\n    return results;\n  }\n\n  sanityCheckCorners({\n    topLeft,\n    topRight,\n    bottomLeft,\n    bottomRight,\n  }: {\n    topLeft: Point;\n    topRight: Point;\n    bottomLeft: Point;\n    bottomRight: Point;\n  }) {\n    function length(p1: Point, p2: Point) {\n      const dx = p1.x - p2.x;\n      const dy = p1.y - p2.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    const topLineLength = length(topLeft, topRight);\n    const leftLineLength = length(topLeft, bottomLeft);\n    const rightLineLength = length(topRight, bottomRight);\n    const bottomLineLength = length(bottomLeft, bottomRight);\n    if (\n      topLineLength < 0.5 * bottomLineLength ||\n      topLineLength > 1.5 * bottomLineLength\n    )\n      return false;\n    if (\n      leftLineLength < 0.7 * rightLineLength ||\n      leftLineLength > 1.3 * rightLineLength\n    )\n      return false;\n    if (\n      leftLineLength < 0.5 * bottomLineLength ||\n      leftLineLength > 1.5 * bottomLineLength\n    )\n      return false;\n    return true;\n  }\n  /**\n   * Process a frame of video\n   */\n  async processFrame() {\n    if (!this.isVideoRunning) {\n      // no video stream so give up immediately\n      return;\n    }\n    if (this.isProcessing) {\n      // we're already processing a frame. Don't kill the computer!\n      return;\n    }\n    try {\n      // grab an image from the video camera\n      let startTime = performance.now();\n      const image = captureImage(this.video);\n      this.captureTime =\n        0.1 * (performance.now() - startTime) + this.captureTime * 0.9;\n\n      // apply adaptive thresholding to the image\n      startTime = performance.now();\n      const thresholded = adaptiveThreshold(image.clone(), 20, 20);\n      this.thresholdTime =\n        0.1 * (performance.now() - startTime) + this.thresholdTime * 0.9;\n\n      // extract the most likely candidate connected region from the image\n      startTime = performance.now();\n      const largestConnectedComponent = getLargestConnectedComponent(\n        thresholded,\n        {\n          minAspectRatio: 0.5,\n          maxAspectRatio: 1.5,\n          minSize:\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.3,\n          maxSize:\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.9,\n        }\n      );\n      this.connectedComponentTime =\n        0.1 * (performance.now() - startTime) +\n        this.connectedComponentTime * 0.9;\n\n      // if we actually found something\n      if (largestConnectedComponent) {\n        // make a guess at where the corner points are using manhattan distance\n        startTime = performance.now();\n        const potentialCorners = getCornerPoints(largestConnectedComponent);\n        this.cornerPointTime =\n          0.1 * (performance.now() - startTime) + this.cornerPointTime * 0.9;\n\n        if (this.sanityCheckCorners(potentialCorners)) {\n          this.corners = potentialCorners;\n\n          // compute the transform to go from a square puzzle of size PROCESSING_SIZE to the detected corner points\n          startTime = performance.now();\n          const transform = findHomographicTransform(\n            PROCESSING_SIZE,\n            this.corners\n          );\n\n          // we've got the transform so we can show where the gridlines are\n          this.gridLines = this.createGridLines(transform);\n\n          // extract the square puzzle from the original grey image\n          const extractedImageGreyScale = extractSquareFromRegion(\n            image,\n            PROCESSING_SIZE,\n            transform\n          );\n          // extract the square puzzle from the thresholded image - we'll use the thresholded image for determining where the digits are in the cells\n          const extractedImageThresholded = extractSquareFromRegion(\n            thresholded,\n            PROCESSING_SIZE,\n            transform\n          );\n          this.extractPuzzleTime =\n            0.1 * (performance.now() - startTime) +\n            this.extractPuzzleTime * 0.9;\n\n          // extract the boxes that should contain the numbers\n          startTime = performance.now();\n          const boxes = extractBoxes(\n            extractedImageGreyScale,\n            extractedImageThresholded\n          );\n          this.extractBoxesTime =\n            0.1 * (performance.now() - startTime) + this.extractBoxesTime * 0.9;\n\n          // did we find sufficient boxes for a potentially valid sudoku puzzle?\n          if (boxes.length > MIN_BOXES) {\n            // apply the neural network to the found boxes and work out what the digits are\n            startTime = performance.now();\n            await fillInPrediction(boxes);\n            this.neuralNetTime =\n              0.1 * (performance.now() - startTime) + this.neuralNetTime * 0.9;\n\n            // solve the suoku puzzle using the dancing links and algorithm X - https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X\n            startTime = performance.now();\n            const solver = new SudokuSolver();\n            // set the known values\n            boxes.forEach((box) => {\n              if (box.contents !== 0) {\n                solver.setNumber(box.x, box.y, box.contents - 1);\n              }\n            });\n            // search for a solution\n            if (solver.search(0)) {\n              this.solvedPuzzle = this.createSolvedPuzzle(solver, transform);\n            } else {\n              this.solvedPuzzle = null;\n            }\n            this.solveTime =\n              0.1 * (performance.now() - startTime) + this.solveTime * 0.9;\n          }\n        } else {\n          this.corners = null;\n          this.gridLines = null;\n          this.solvedPuzzle = null;\n        }\n      } else {\n        this.corners = null;\n        this.gridLines = null;\n        this.solvedPuzzle = null;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n    this.isProcessing = false;\n    // process again\n    setTimeout(() => this.processFrame(), 20);\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/sudoku/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
